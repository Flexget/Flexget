import logging
import copy
import hashlib
from flexget import validator
from flexget.manager import Session, register_config_key
from flexget.plugin import get_plugins_by_phase, get_plugin_by_name, \
    feed_phases, PluginWarning, PluginError, DependencyError, plugins as all_plugins
from flexget.utils.simple_persistence import SimpleFeedPersistence
import flexget.utils.requests as requests
from flexget.event import fire_event
from flexget.entry import Entry, EntryUnicodeError
from functools import wraps

log = logging.getLogger('feed')


def useFeedLogging(func):

    @wraps(func)
    def wrapper(self, *args, **kw):
        # Set the feed name in the logger
        from flexget import logger
        logger.set_feed(self.name)
        try:
            return func(self, *args, **kw)
        finally:
            logger.set_feed('')

    return wrapper


class Feed(object):

    """
    Represents one feed in the configuration.

    **Fires events:**

    * feed.execute.before_plugin

      Before a plugin is about to be executed. Note that since this will also include all
      builtin plugins the amount of calls can be quite high

      ``parameters: feed, keyword``

    * feed.execute.after_plugin

      After a plugin has been executed.

      ``parameters: feed, keyword``

    * feed.execute.completed

      After feed execution has been completed

      ``parameters: feed``

    """

    max_reruns = 5

    def __init__(self, manager, name, config):
        """
        :param Manager manager: Manager instance.
        :param string name: Name of the feed.
        :param dict config: Feed configuration.
        """
        self.name = unicode(name)
        self.config = config
        self.manager = manager

        # simple persistence
        self.simple_persistence = SimpleFeedPersistence(self)

        # not to be reseted
        self._rerun_count = 0

        # This should not be used until after process_start, when it is evaluated
        self.config_modified = None

        # use reset to init variables when creating
        self._reset()

    def _reset(self):
        """Reset feed state"""
        log.debug('resetting %s' % self.name)
        self.enabled = True
        self.session = None
        self.priority = 65535

        self.requests = requests.Session()

        # undecided entries in the feed (created by input)
        self.entries = []

        # You should NOT change these arrays, use reject, accept and fail methods!
        self.accepted = [] # accepted entries, can still be rejected
        self.rejected = [] # rejected entries
        self.failed = []   # failed entries

        self.disabled_phases = []

        # TODO: feed.abort() should be done by using exception? not a flag that has to be checked everywhere
        self._abort = False

        self._rerun = False

        # current state
        self.current_phase = None
        self.current_plugin = None

    def __cmp__(self, other):
        return cmp(self.priority, other.priority)

    def __str__(self):
        return '<Feed(name=%s,aborted=%s)>' % (self.name, str(self._abort))

    @property
    def undecided(self):
        """Iterate over undecided entries"""
        return (entry for entry in self.entries if not entry in self.accepted and entry not in self.rejected)

    def purge(self):
        """
        Purges rejected and failed entries.
        Failed entries will be removed from :attr:`entries`, :attr:`accepted` and :attr:`rejected`
        Rejected entries will be removed from :attr:`entries` and :attr:`accepted`
        """
        self.__purge_failed()
        self.__purge_rejected()

    def __purge_failed(self):
        """Purge failed entries from feed."""
        self.__purge(self.failed, self.entries)
        self.__purge(self.failed, self.rejected)
        self.__purge(self.failed, self.accepted)

    def __purge_rejected(self):
        """Purge rejected entries from feed."""
        self.__purge(self.rejected, self.entries)
        self.__purge(self.rejected, self.accepted)

    def __purge(self, purge_what, purge_from):
        """Purge entries in list from feed.entries"""
        # TODO: there is probably more efficient way to do this now that I got rid of __count
        for entry in purge_what:
            if entry in purge_from:
                purge_from.remove(entry)

    def disable_phase(self, phase):
        """Disable ``phase`` from execution.

        All disabled phases are re-enabled by :meth:`Feed._reset()` after feed
        execution has been completed.

        :param string phase: Name of ``phase``
        :raises ValueError: *phase* could not be found.
        """
        if phase not in feed_phases:
            raise ValueError('%s is not a valid phase' % phase)
        if phase not in self.disabled_phases:
            log.debug('Disabling %s phase' % phase)
            self.disabled_phases.append(phase)

    def accept(self, entry, reason=None, **kwargs):
        """
        Accept *entry* immediately with optional but
        highly recommendable *reason*.

        :param Entry entry: To be aceppeted
        :param string reason: Optional reason
        :param kwargs: Optional kwargs will be passed to plugins hooking action
        """
        if not isinstance(entry, Entry):
            raise Exception('Trying to accept non entry, %r' % entry)
        if entry in self.rejected:
            log.debug('tried to accept rejected %r' % entry)
        if entry not in self.accepted and entry not in self.rejected:
            self.accepted.append(entry)
            # Run on_entry_accept phase
            self.__run_entry_phase('accept', entry, reason=reason, **kwargs)

    def reject(self, entry, reason=None, **kwargs):
        """
        Reject *entry* immediately and permanently with optional but
        highly recommendable *reason*.

        :param Entry entry: To be rejected
        :param string reason: Optional reason
        :param kwargs: Optional kwargs will be passed to plugins hooking action
        """
        if not isinstance(entry, Entry):
            raise Exception('Trying to reject non entry, %r' % entry)
        # ignore rejections on immortal entries
        if entry.get('immortal'):
            reason_str = '(%s)' % reason if reason else ''
            log.info('Tried to reject immortal %s %s' % (entry['title'], reason_str))
            self.trace(entry, 'Tried to reject immortal %s' % reason_str)
            return

        if not entry in self.rejected:
            self.rejected.append(entry)
            # Run on_entry_reject phase
            self.__run_entry_phase('reject', entry, reason=reason, **kwargs)

    def fail(self, entry, reason=None, **kwargs):
        """
        Fails *entry* immediately with optional but
        highly recommendable *reason*.

        :param Entry entry: To be failed
        :param string reason: Optional reason
        :param kwargs: Optional kwargs will be passed to plugins hooking action
        """
        log.debug('Marking entry \'%s\' as failed' % entry['title'])
        if not entry in self.failed:
            self.failed.append(entry)
            log.error('Failed %s (%s)' % (entry['title'], reason))
            # Run on_entry_fail phase
            self.__run_entry_phase('fail', entry, reason=reason, **kwargs)

    def trace(self, entry, message):
        """Add tracing message to entry.

        .. note:: Not yet supported in any meaningful way
        """
        entry.trace.append((self.current_plugin, message))

    def abort(self, **kwargs):
        """Abort this feed execution, no more plugins will be executed after the current one exists."""
        if self._abort:
            return
        if not kwargs.get('silent', False):
            log.info('Aborting feed (plugin: %s)' % self.current_plugin)
        else:
            log.debug('Aborting feed (plugin: %s)' % self.current_plugin)
        # Run the abort phase before we set the _abort flag
        self._abort = True
        self.__run_feed_phase('abort')

    def find_entry(self, category='entries', **values):
        """
        Find and return :class:`~flexget.entry.Entry` with given attributes from feed or None

        :param string category: entries, accepted, rejected or failed. Defaults to entries.
        :param values: Key values of entries to be searched
        :return: Entry or None
        """
        cat = getattr(self, category)
        if not isinstance(cat, list):
            raise TypeError('category must be a list')
        for entry in cat:
            for k, v in values.iteritems():
                if not (k in entry and entry[k] == v):
                    break
            else:
                return entry
        return None

    def plugins(self, phase=None):
        """Get currently enabled plugins.

        :param string phase:
          Optional, limits to plugins currently configured on given phase, sorted in phase order.
        :return:
          An iterator over configured :class:`flexget.plugin.PluginInfo` instances enabled on this feed.
        """
        if phase:
            plugins = sorted(get_plugins_by_phase(phase), key=lambda p: p.phase_handlers[phase], reverse=True)
        else:
            plugins = all_plugins.itervalues()
        return (p for p in plugins if p.name in self.config or p.builtin)

    def __run_feed_phase(self, phase):
        """Executes feed phase, ie. call all enabled plugins on the feed.

        Fires events:

        * feed.execute.before_plugin
        * feed.execute.after_plugin

        :param string phase: Name of the phase
        """
        if phase not in feed_phases + ['abort', 'process_start', 'process_end']:
            raise Exception('%s is not a valid feed phase' % phase)
        # warn if no inputs, filters or outputs in the feed
        if phase in ['input', 'filter', 'output']:
            if not self.manager.unit_test:
                # Check that there is at least one manually configured plugin for these phases
                for p in self.plugins(phase):
                    if not p.builtin:
                        break
                else:
                    log.warning('Feed doesn\'t have any %s plugins, you should add (at least) one!' % phase)

        for plugin in self.plugins(phase):
            # Abort this phase if one of the plugins disables it
            if phase in self.disabled_phases:
                return
            # store execute info, except during entry events
            self.current_phase = phase
            self.current_plugin = plugin.name

            if plugin.api_ver == 1:
                # backwards compatibility
                # pass method only feed (old behaviour)
                args = (self,)
            else:
                # pass method feed, copy of config (so plugin cannot modify it)
                args = (self, copy.copy(self.config.get(plugin.name)))

            try:
                fire_event('feed.execute.before_plugin', self, plugin.name)
                response = self.__run_plugin(plugin, phase, args)
                if phase == 'input' and response:
                    # add entries returned by input to self.entries
                    self.entries.extend(response)
                # purge entries between plugins
                self.purge()
            finally:
                fire_event('feed.execute.after_plugin', self, plugin.name)

            # Make sure we abort if any plugin sets our abort flag
            if self._abort and phase != 'abort':
                return

    def __run_entry_phase(self, phase, entry, **kwargs):
        # TODO: entry events are not very elegant, refactor into real (new) events or something ...
        if phase not in ['accept', 'reject', 'fail']:
            raise Exception('Not a valid entry phase')
        phase_plugins = self.plugins(phase)
        for plugin in phase_plugins:
            self.__run_plugin(plugin, phase, (self, entry), kwargs)

    def __run_plugin(self, plugin, phase, args=None, kwargs=None):
        """
        Execute given plugins phase method, with supplied args and kwargs.
        If plugin throws unexpected exceptions :meth:`abort` will be called.

        :param PluginInfo plugin: Plugin to be executed
        :param string phase: Name of the phase to be executed
        :param args: Passed to the plugin
        :param kwargs: Passed to the plugin
        """
        keyword = plugin.name
        method = plugin.phase_handlers[phase]
        if args is None:
            args = []
        if kwargs is None:
            kwargs = {}

        # log.trace('Running %s method %s' % (keyword, method))
        # call the plugin
        try:
            return method(*args, **kwargs)
        except PluginWarning, warn:
            # check if this warning should be logged only once (may keep repeating)
            if warn.kwargs.get('log_once', False):
                from flexget.utils.log import log_once
                log_once(warn.value, warn.log)
            else:
                warn.log.warning(warn)
        except EntryUnicodeError, eue:
            log.critical('Plugin %s tried to create non-unicode compatible entry (key: %s, value: %r)' %
                (keyword, eue.key, eue.value))
            self.abort()
        except PluginError, err:
            err.log.critical(err)
            self.abort()
        except DependencyError, e:
            log.critical('Plugin `%s` cannot be used because dependency `%s` is missing.' %
                (keyword, e.missing))
            log.debug(e.message)
            self.abort()
        except Exception, e:
            log.exception('BUG: Unhandled error in plugin %s: %s' % (keyword, e))
            self.abort()
            # don't handle plugin errors gracefully with unit test
            if self.manager.unit_test:
                raise

    def rerun(self):
        """Immediately re-run the feed after execute has completed,
        feed can be re-run up to :attr:`.max_reruns` times."""
        self._rerun = True
        log.info('Plugin %s has requested feed to be ran again after execution has completed.' %
                 self.current_plugin)

    @useFeedLogging
    def execute(self, disable_phases=None, entries=None):
        """Executes the feed.

        :param list disable_phases: Disable given phases names during execution
        :param list entries: Entries to be used in execution instead
            of using the input. Disables input phase.
        """

        log.debug('executing %s' % self.name)

        self._reset()
        # Handle keyword args
        if disable_phases:
            map(self.disable_phase, disable_phases)
        if entries:
            # If entries are passed for this execution (eg. rerun), disable the input phase
            self.disable_phase('input')
            self.entries.extend(entries)

        # validate configuration
        errors = self.validate()
        if self._abort: # todo: bad practice
            return
        if errors and self.manager.unit_test: # todo: bad practice
            raise Exception('configuration errors')
        if self.manager.options.validate:
            if not errors:
                log.info('Feed \'%s\' passed' % self.name)
            return

        log.debug('starting session')
        self.session = Session()

        try:
            # run phases
            for phase in feed_phases:
                if phase in self.disabled_phases:
                    # log keywords not executed
                    for plugin in self.plugins(phase):
                        if plugin.name in self.config:
                            log.info('Plugin %s is not executed because %s phase is disabled' %
                                     (plugin.name, phase))
                    continue

                # run all plugins with this phase
                self.__run_feed_phase(phase)

                # if abort flag has been set feed should be aborted now
                # since this calls return rerun will not be done
                if self._abort:
                    return

            log.debug('committing session, abort=%s' % self._abort)
            self.session.commit()
            fire_event('feed.execute.completed', self)
        finally:
            # this will cause database rollback on exception and feed.abort
            self.session.close()

        # rerun feed
        if self._rerun:
            if self._rerun_count >= self.max_reruns:
                log.info('Feed has been rerunning already %s times, stopping for now' % self._rerun_count)
                # reset the counter for future runs (necessary only with webui)
                self._rerun_count = 0
            else:
                log.info('Rerunning the feed in case better resolution can be achieved.')
                self._rerun_count += 1
                self.execute(disable_phases=disable_phases, entries=entries)

    def _process_start(self):
        """Execute process_start phase"""
        self.__run_feed_phase('process_start')
        config_hash = hashlib.md5(str(self.config.items())).hexdigest()
        if self.simple_persistence.get('feed_config_hash') != config_hash:
            self.config_modified = True
            self.simple_persistence['feed_config_hash'] = config_hash
        else:
            self.config_modified = False

    def _process_end(self):
        """Execute terminate phase for this feed"""
        if self.manager.options.validate:
            log.debug('No process_end phase with --check')
            return
        self.__run_feed_phase('process_end')

    def validate(self):
        """Called during feed execution. Validates config, prints errors and aborts feed if invalid."""
        errors = self.validate_config(self.config)
        # log errors and abort
        if errors:
            log.critical('Feed \'%s\' has configuration errors:' % self.name)
            for error in errors:
                log.error(error)
            # feed has errors, abort it
            self.abort()
        return errors

    @staticmethod
    def validate_config(config):
        """Plugin configuration validation. Return list of error messages that were detected."""
        validate_errors = []
        # validate config is a dictionary
        if not isinstance(config, dict):
            validate_errors.append('Config is not a dictionary.')
            return validate_errors
        # validate all plugins
        for keyword in config:
            if keyword.startswith('_'):
                continue
            try:
                plugin = get_plugin_by_name(keyword)
            except:
                validate_errors.append('Unknown plugin \'%s\'' % keyword)
                continue
            if hasattr(plugin.instance, 'validator'):
                try:
                    validator = plugin.instance.validator()
                except TypeError, e:
                    log.critical('Invalid validator method in plugin %s' % keyword)
                    log.exception(e)
                    continue
                if not validator.name == 'root':
                    # if validator is not root type, add root validator as it's parent
                    validator = validator.add_root_parent()
                if not validator.validate(config[keyword]):
                    for msg in validator.errors.messages:
                        validate_errors.append('%s %s' % (keyword, msg))
            else:
                log.warning('Used plugin %s does not support validating. Please notify author!' % keyword)

        return validate_errors


def root_config_validator():
    """Returns a validator for the 'feeds' key of config."""
    # TODO: better error messages
    valid_plugins = [p for p in all_plugins if hasattr(all_plugins[p].instance, 'validator')]
    root = validator.factory('dict')
    root.reject_keys(valid_plugins, message='plugins should go under a specific feed. '
        '(and feeds are not allowed to be named the same as any plugins)')
    root.accept_any_key('dict').accept_any_key('any')
    return root


register_config_key('feeds', root_config_validator)
